<?php
// $Id$

/**
 * @file
 * Location module main routines.
 * An implementation of a universal API for location manipulation.  Provides functions for
 * postal_code proximity searching, deep-linking into online mapping services.  Currently,
 * some options are configured through an interface provided by location.module.
 */

define('LOCATION_PATH',                   drupal_get_path('module', 'location'));

define('LOCATION_LATLON_UNDEFINED',       0);
define('LOCATION_LATLON_USER_SUBMITTED',  1);
define('LOCATION_LATLON_GEOCODED_APPROX', 2);
define('LOCATION_LATLON_GEOCODED_EXACT',  3);

define('LOCATION_USER_DONT_COLLECT',      0);
define('LOCATION_USER_COLLECT',           1);

include_once LOCATION_PATH .'/location.inc';

/**
 * Implementation of hook_menu().
 */
function location_menu() {
  $items = array();

  $items['location/autocomplete'] = array(
    'access arguments' => array('access content'),
    'page callback' => '_location_autocomplete',
    'type' => MENU_CALLBACK,
  );

  $items['admin/settings/location'] = array(
    'title' => 'Location',
    'description' => 'Settings for Location module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('location_admin_settings'),
    'file' => 'location.admin.inc',
    'access arguments' => array('administer site configuration'),
  );
  $items['admin/settings/location/main'] = array(
    'title' => 'Main settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/settings/location/maplinking'] = array(
    'title' => 'Map links',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('location_map_link_options_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'location.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  $items['admin/settings/location/geocoding'] = array(
    'title' => 'Geocoding options',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('location_geocoding_options_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'location.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['admin/settings/location/geocoding/%/%'] = array(
    'page callback' => 'location_geocoding_parameters_page',
    'page arguments' => array(4, 5),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function location_perm() {
  return array(
    'submit latitude/longitude',
    'administer user locations',
    'set own user location',
    'view own user location',
    'view all user locations',
  );
}

/**
 * Implementation of hook_help().
 *
 * @TODO: check/fix this: admin/content/configure/types (still use %? still same url?)
 */
function location_help($path, $arg) {
  switch ($path) {
    case 'admin/help#location':
      $output = '<p>'. t('The location module allows you to associate a geographic location with content and users. Users can do proximity searches by postal code.  This is useful for organizing communities that have a geographic presence.') .'</p>';
      $output .= '<p>'. t('To administer locative information for content, use the content type administration page.  To support most location enabled features, you will need to install the country specific include file.  To support postal code proximity searches for a particular country, you will need a database dump of postal code data for that country.  As of June 2007 only U.S. and German postal codes are supported.') .'</p>';
      $output .= t('<p>You can</p>
<ul>
<li>administer locative information at <a href="@admin-node-configure-types">Administer &gt;&gt; Content management &gt;&gt; Content types</a> to configure a type and see the locative information.</li>
<li>administer location at <a href="@admin-settings-location">Administer &gt;&gt; Site configuration &gt;&gt; Location</a>.</li>
<li>use a database dump for a U.S. and/or German postal codes table that can be found at <a href="@external-http-cvs-drupal-org">zipcode database</a>.</li>
', array('@admin-node-configure-types' => url('admin/content/types'), '@admin-settings-location' => url('admin/settings/location'), '@external-http-cvs-drupal-org' => 'http://cvs.drupal.org/viewcvs/drupal/contributions/modules/location/database/')) .'</ul>';
      $output .= '<p>'. t('For more information please read the configuration and customization handbook <a href="@location">Location page</a>.', array('@location' => 'http://www.drupal.org/handbook/modules/location/')) .'</p>';
      return $output;
  }
}

/**
 * Implementation of hook_elements().
 */
function location_elements() {
  return array(
    'location_element' => array(
      '#input' => TRUE,
      '#process' => array('_location_expand_location'),
      '#tree' => TRUE,
      '#location_settings' => array(),
      '#attributes' => array('class' => 'location'),
      // Element level validation.
      '#validate' => array('location_element_validate' => array()),
    ),
    'location_settings' => array(
      '#input' => TRUE,
      '#process' => array('_location_expand_location_settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#tree' => TRUE,
    ),
  );
}

/**
 * Theme function to fixup location elements.
 * @ingroup themable
 */
function theme_location_element($element) {
  // Prevent spurious "Array" from appearing.
  unset($element['#value']);
  return theme('fieldset', $element);
}

/**
 * Implementation of hook_theme().
 */
function location_theme() {
  return array(
    'location_settings' => array('arguments' => array('element')),
    'locations' => array(
      'template' => 'locations',
      'arguments' => array(
        'locations' => NULL,
        'hide' => array(),
      ),
    ),
    'location' => array(
      'template' => 'location',
      'arguments' => array(
        'location' => NULL,
        'hide' => array(),
      ),
    ),
    'location_latitude_dms' => array('arguments' => array('latitude')),
    'location_longitude_dms' => array('arguments' => array('longitude')),
    'location_map_link_options' => array('arguments' => array('form')),
    'location_geocoding_options' => array('arguments' => array('form')),
    'location_element' => array('arguments' => array('element')),
    'location_distance' => array('template' => 'location_distance', 'arguments' => array('distance' => 0, 'units' => 'km')),
  );
}

/**
 * Implementation of hook_simpletest().
 */
function location_simpletest() {
  $dir = drupal_get_path('module', 'location') .'/tests';
  $tests = file_scan_directory($dir, '\.test$');
  return array_keys($tests);
}

/**
 * Implementation of hook_views_api().
 */
function location_views_api() {
  return array(
    'api' => 2,
    //'path' => drupal_get_path('module', 'location') .'/includes',
  );
}

/**
 * Process a location element.
 */
function _location_expand_location($element) {
  drupal_add_css(drupal_get_path('module', 'location') .'/location.css');
  $value = is_array($element['#value']) ? $element['#value'] : array();
  $element['#tree'] = TRUE;

  if (!isset($element['#title'])) {
    $element['#title'] = t('Location');
  }
  if (empty($element['#location_settings'])) {
    $element['#location_settings'] = array();
  }
  if (!isset($element['#default_value']) || $element['#default_value'] == 0) {
    $element['#default_value'] = array();
  }

  // Merge defaults in.
  $dummy = array();
  $element['#location_settings'] = array_merge(location_invoke_locationapi($dummy, 'collection default'), $element['#location_settings']);
  $element['#default_value'] = array_merge(location_invoke_locationapi($dummy, 'default values'), $element['#default_value']);

  $dv =& $element['#default_value'];

  // Keep track of the LID.
  // @@@ For some reason, hidden seems to work best.
  $element['lid'] = array(
    '#type' => 'hidden',
    '#value' => isset($dv['lid']) ? $dv['lid'] : FALSE,
  );

  $location_settings = $element['#location_settings'];

  $fields = location_field_names();
  foreach ($fields as $field => $title) {
    if (!isset($element[$field])) {
      // @@@ Permission check hook?
      if ($location_settings[$field] != 0) {
        $element[$field] = location_invoke_locationapi($dv[$field], 'field_expand', $field, $location_settings[$field], $dv);
      }

      // Only include 'Street Additional' if 'Street' is 'allowed' or 'required'
      if ($field == 'street' && $location_settings[$field]) {
        $element['additional'] = location_invoke_locationapi($dv['additional'], 'field_expand', 'additional', 1, $dv);
      }
    }
  }
  // @@@ Split into submit and view permissions?
  if (user_access('submit latitude/longitude')) {
    $element['locpick'] = array();

    if (location_has_coordinates($dv, FALSE)) {
      $element['locpick']['current'] = array(
        '#type' => 'fieldset',
        '#title' => t('Current coordinates'),
      );
      $element['locpick']['current']['current_latitude'] = array(
        '#type' => 'item',
        '#title' => t('Latitude'),
        '#value' => $dv['latitude'],
      );
      $element['locpick']['current']['current_longitude'] = array(
        '#type' => 'item',
        '#title' => t('Longitude'),
        '#value' => $dv['longitude'],
      );
      $source = t('Unknown');
      switch($dv['source']) {
        case LOCATION_LATLON_USER_SUBMITTED:
          $source = t('User-submitted');
          break;
        case LOCATION_LATLON_GEOCODED_APPROX:
          $source = t('Geocoded (Postal code level)');
          break;
        case LOCATION_LATLON_GEOCODED_EXACT:
          $source = t('Geocoded (Exact)');
      }
      $element['locpick']['current']['current_source'] = array(
        '#type' => 'item',
        '#title' => t('Source'),
        '#value' => $source,
      );
    }

    $element['locpick']['user_latitude'] = array(
      '#type' => 'textfield',
      '#title' => t('Latitude'),
      '#default_value' => isset($element['#default_value']['locpick']['user_latitude']) ? $element['#default_value']['locpick']['user_latitude'] : '',
      '#size' => 16,
      '#attributes' => array('class' => 'container-inline'),
      '#maxlength' => 20,
    );
    $element['locpick']['user_longitude'] = array(
      '#type' => 'textfield',
      '#title' => t('Longitude'),
      '#default_value' => isset($element['#default_value']['locpick']['user_longitude']) ? $element['#default_value']['locpick']['user_longitude'] : '',
      '#size' => 16,
      '#maxlength' => 20,
    );

    $element['locpick']['instructions'] = array(
      '#type' => 'markup',
      '#weight' => 1,
      '#prefix' => '<div class=\'description\'>',
      '#value' => '<br /><br />' . t('If you wish to supply your own latitude and longitude, you may enter them above.  If you leave these fields blank, the system will attempt to determine a latitude and longitude for you from the entered address.  To have the system recalculate your location from the address, for example if you change the address, delete the values for these fields.'),
      '#suffix' => '</div>',
      );
    if (function_exists('gmap_get_auto_mapid') && variable_get('location_usegmap', FALSE)) {
      $mapid = gmap_get_auto_mapid();
      $map = gmap_parse_macro(variable_get('location_locpick_macro', '[gmap]'));
      $map['id'] = $mapid;
      $map['points'] = array();
      $map['pointsOverlays'] = array();
      $map['lines'] = array();

      $map['behavior']['locpick'] = TRUE;
      $map['behavior']['collapsehack'] = TRUE;
      // Use previous coordinates to center the map.
      if (location_has_coordinates($dv, FALSE)) {
        $map['latitude'] = (float)$dv['latitude'];
        $map['longitude'] = (float)$dv['longitude'];

        $map['markers'][] = array(
          'latitude' => $dv['latitude'],
          'longitude' => $dv['longitude'],
          'markername' => 'small gray', // @@@ Settable?
          'offset' => 0,
          'opts' => array(
            'clickable' => FALSE,
          ),
        );
      }
      $element['locpick']['user_latitude']['#map'] = $mapid;
      gmap_widget_setup($element['locpick']['user_latitude'], 'locpick_latitude');
      $element['locpick']['user_longitude']['#map'] = $mapid;
      gmap_widget_setup($element['locpick']['user_longitude'], 'locpick_longitude');

      $element['locpick']['map'] = array(
        '#type' => 'gmap',
        '#weight' => -1,
        '#map' => $mapid,
        '#settings' => $map,
      );
      $element['locpick']['map_instructions'] = array(
        '#type' => 'markup',
        '#weight' => 2,
        '#prefix' => '<div class=\'description\'>',
        '#value' => t('You may set the location by clicking on the map, or dragging the location marker.  To clear the location and cause it to be recalculated, click on the marker.'),
        '#suffix' => '</div>',
      );
    }

    if (isset($dv['lid']) && $dv['lid'] !== FALSE) {
      $element['delete_location'] = array(
        '#type' => 'checkbox',
        '#title' => t('Delete'),
        '#default_value' => FALSE,
        '#description' => t('Check this box to delete this location.'),
      );
    }
  }

  $element += _element_info('fieldset');
  return $element;
}

function _location_expand_location_settings(&$element) {
  // Set a value for the fieldset that doesn't interfere with rendering and doesn't generate a warning.
  $element['#value'] = '';
  $element['#tree'] = TRUE;
  $element['#type'] = 'fieldset';

  if (!isset($element['#title'])) {
    $element['#title'] = t('Location Fields');
  }
  if (!isset($element['#default_value']) || $element['#default_value'] == 0) {
    $element['#default_value'] = array();
  }

  // Force #tree on.
  $element['#tree'] = TRUE;

  $defaults = location_invoke_locationapi($element, 'collection default');
  $defaults = array_merge($defaults, $element['#default_value']);

  $fields = location_field_names();

  // Options for fields.
  $options = array(
    t('Do not collect'),
    t('Allow'),
    t('Require'),
  );
  foreach ($fields as $field => $title) {
    $element[$field] = array(
      '#type'           => 'radios',
      '#title'          => $title,
      '#default_value'  => $defaults[$field],
      '#options'        => $options,
      '#tree'           => TRUE,
    );
  }

  // Override country field.
  $element['country'] = array(
    '#type'           => 'radios',
    '#title'          => t('Country names'),
    '#description'    => t('When using "Force Default", the country field will be set to the value of the "Default country selection" dropdown on the <a href="@location_settings">location settings page</a> and hidden from the user.', array('@location_settings' => url('admin/settings/location'))),
    '#default_value'  => $defaults['country'],
    '#options'        => array(
      // 0 is omitted so the behavior lines up properly with everything else.
      1 => t('Use'),
      2 => t('Require'),
      3 => t('Force Default'),
    ),
  );

  // 'Street Additional' field should depend on 'Street' setting.
  // It should never be required and should only display when the street field is 'allowed' or 'required'
  unset($element['additional']);

  // @@@ Alter here?

  return $element;
}

function theme_location_settings($element) {
  return theme('form_element', $element, $element['#children']);
}

function location_field_names($all = FALSE) {
  static $fields;
  static $allfields;
  if ($all) {
    if (empty($allfields)) {
      $dummy = array();
      $allfields = location_invoke_locationapi($dummy, 'fields');
      $virtual = location_invoke_locationapi($dummy, 'virtual fields');
      $allfields += $virtual;
    }
    return $allfields;
  }
  else {
    if (empty($fields)) {
      $dummy = array();
      $fields = location_invoke_locationapi($dummy, 'fields');
    }
    return $fields;
  }
}

/**
 * Implementation of hook_locationapi().
 */
function location_locationapi(&$obj, $op, $a3 = NULL, $a4 = NULL, $a5 = NULL) {
  switch ($op) {
    case 'fields':
      return array('name' => t('Location name'), 'street' => t('Street location'), 'additional' => t('Additional'), 'city' => t('City'), 'province' => t('State/Province'), 'postal_code' => t('Postal code'), 'country' => t('Country'));

    case 'virtual fields':
      return array('province_name' => t('Province name'), 'country_name' => t('Country name'), 'map_link' => t('Map link'));

    case 'collection default':
      return array('name' => 1, 'street' => 1, 'additional' => 1, 'city' => 0, 'province' => 0, 'postal_code' => 0, 'country' => 1);

    case 'default values':
      return array(
        'name' => '',
        'street' => '',
        'additional' => '',
        'city' => '',
        'province' => '',
        'postal_code' => '',
        'country' => variable_get('location_default_country', 'us'),
        'latitude' => 0,
        'longitude' => 0,
        'source' => LOCATION_LATLON_UNDEFINED,
        'is_primary' => 0, // @@@
      );

    case 'validate':
      if (!empty($obj['country'])) {
        if (!empty($obj['province'])) {
          $provinces = location_get_provinces($obj['country']);
          $found = FALSE;
          $p = strtoupper($obj['province']);
          foreach ($provinces as $k => $v) {
            if ($p == strtoupper($k) || $p == strtoupper($v)) {
              $found = TRUE;
              break;
            }
          }
          if (!$found) {
            form_error($a3['province'], t('The specified province was not found in the specified country.'));
          }
        }
      }

      // Can't specify just latitude or just longitude.
      if (_location_floats_are_equal($obj['locpick']['user_latitude'], 0) xor _location_floats_are_equal($obj['locpick']['user_longitude'], 0)) {
        $ref = &$a3['locpick']['user_latitude'];
        if (_location_floats_are_equal($obj['locpick']['user_longitude'], 0)) {
          $ref = &$a3['locpick']['user_longitude'];
        }
        form_error($ref, t('You must fill out both latitude and longitude or you must leave them both blank.'));
      }

      break;

    case 'field_expand':
      switch ($a3) {
        case 'name':
          return array(
            '#type'           => 'textfield',
            '#title'          => t('Location name'),
            '#default_value'  => $obj,
            '#size'           => 64,
            '#maxlength'      => 64,
            '#description'    => t('e.g. a place of business, venue, meeting point'),
            '#attributes'     => NULL,
            '#required'       => ($a4 == 2),
          );

        case 'street':
          return array(
            '#type'           => 'textfield',
            '#title'          => t('Street'),
            '#default_value'  => $obj,
            '#size'           => 64,
            '#maxlength'      => 64,
            '#required'       => ($a4 == 2),
          );

        // Additional is linked to street.
        case 'additional':
          return array(
            '#type'           => 'textfield',
            '#title'          => t('Additional'),
            '#default_value'  => $obj,
            '#size'           => 64,
            '#maxlength'      => 64,
            // Required is forced OFF because this is technically part of street.
          );

        case 'city':
          return array(
            '#type'           => 'textfield',
            '#title'          => t('City'),
            '#default_value'  => $obj,
            '#size'           => 64,
            '#maxlength'      => 64,
            '#description'    => NULL,
            '#attributes'     => NULL,
            '#required'       => ($a4 == 2),
          );

        case 'province':
          drupal_add_js(drupal_get_path('module', 'location') .'/location_autocomplete.js');
          return array(
            '#type' => 'textfield',
            '#title' => t('State/Province'),
            '#autocomplete_path' => 'location/autocomplete/'. $a5['country'],
            '#default_value' => $obj,
            '#size' => 64,
            '#maxlength' => 64,
            '#description' => NULL,
            // Used by province autocompletion js.
            '#attributes' => array('class' => 'location_auto_province'),
            '#required' => ($a4 == 2),
          );

        case 'country':
          // Force default.
          if ($a4 == 3) {
            return array(
              '#type' => 'value',
              '#value' => variable_get('location_default_country', 'us'),
            );
          }
          else {
            $options = array_merge(array('' => t('Please select'), 'xx' => 'NOT LISTED'), location_get_iso3166_list());
            return array(
              '#type'           => 'select',
              '#title'          => t('Country'),
              '#default_value'  => $obj,
              '#options'        => $options,
              '#description'    => NULL,
              '#required'       => ($a4 == 2),
              // Used by province autocompletion js.
              '#attributes'     => array('class' => 'location_auto_country'),
            );
          }
          break;

        case 'postal_code':
          return array(
            '#type'           => 'textfield',
            '#title'          => t('Postal code'),
            '#default_value'  => $obj,
            '#size'           => 16,
            '#maxlength'      => 16,
            '#required'       => ($a4 == 2),
          );
      }
      break;

    case 'isunchanged':
      if ($a3 == 'latitude' || $a3 == 'longitude') {
        if (_location_floats_are_equal($obj[$a3], $a4)) {
          return TRUE;
        }
      }
      if ($a3 == 'country') {
        // Consider '  ' and '' to be equivilent, due to us storing country
        // as char(2) in the database.
        if (trim($obj[$a3]) == trim($a4)) {
          return TRUE;
        }
      }
      break;

    case 'instance_links':
      foreach ($obj as $k => $v) {
        if ($v['nid'] != 0) {
          $node = node_load($v['nid']);
          $obj[$k]['href'] = 'node/'. $v['nid'];
          $obj[$k]['title'] = $node->title;
        }
        else if ($v['uid'] != 0) {
          $account = user_load(array('uid' => $v['uid']));
          $obj[$k]['href'] = 'user/'. $v['uid'];
          $obj[$k]['title'] = $account->name;
        }
      }
      break;

  }
}

function location_geocoding_parameters_page($country_iso, $service) {
  drupal_set_title(t('Configure parameters for %service geocoding', array('%service' => $service)));

  $breadcrumbs = drupal_get_breadcrumb();
  $breadcrumbs[] = l('location', 'admin/settings/location');
  $breadcrumbs[] = l('geocoding', 'admin/settings/location/geocoding');
  $countries = location_get_iso3166_list();
  $breadcrumbs[] = l($countries[$country_iso], 'admin/settings/location/geocoding', array('fragment' => $country_iso));
  drupal_set_breadcrumb($breadcrumbs);
  return drupal_get_form('location_geocoding_parameters_form', $country_iso, $service);
}

function location_geocoding_parameters_form(&$form_state, $country_iso, $service) {
  location_load_country($country_iso);
  $geocode_settings_form_function_specific = 'location_geocode_'. $country_iso .'_'. $service .'_settings';
  $geocode_settings_form_function_general = $service .'_geocode_settings';
  if (function_exists($geocode_settings_form_function_specific)) {
    return system_settings_form($geocode_settings_form_function_specific());
  }
  location_load_geocoder($service);
  if (function_exists($geocode_settings_form_function_general)) {
    return system_settings_form($geocode_settings_form_function_general());
  }
  else {
    return system_settings_form(array(
      '#type' => 'markup',
      '#value' => t('No configuration parameters are necessary, or a form to take such paramters has not been implemented.')
    ));
  }
}

/**
 * Alter the node_type_form form.
 */
function location_form_node_type_form_alter(&$form, &$form_state) {
  $type = $form['#node_type']->type;

  // Hook the form handlers so we can correctly extract our information;
  // the node type form doesn't handle nested values correctly.
  array_unshift($form['#validate'], 'location_node_settings_validate');
  //array_unshift($form['#submit'], 'node_type_form_submit');
  array_unshift($form['#submit'], '_location_node_type_save_submit');

  $settings = variable_get('location_settings_node_'. $type, array());
  $form['location_settings'] = location_settings($settings);

  // Tack on customizations for node settings.
  $form['location_settings']['display']['teaser'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display location in teaser view'),
    '#default_value' => isset($settings['display']['teaser']) ? $settings['display']['teaser'] : TRUE,
    '#weight' => -2,
  );
  $form['location_settings']['display']['full'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display location in full view'),
    '#default_value' => isset($settings['display']['full']) ? $settings['display']['full'] : TRUE,
    '#weight' => -1,
  );
  $form['location_settings']['rss'] = array(
    '#type' => 'fieldset',
    '#title' => t('RSS Settings'),
    '#description' => t('Here, you can change how locative data affects RSS feeds on nodes.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#weight' => 5,
  );
  $form['location_settings']['rss']['mode'] = array(
    '#type' => 'select',
    '#title' => t('RSS mode'),
    '#description' => t('Select how to use locations in RSS feeds for this content type.'),
    '#options' => array(
      'none' => t('None (Do not put locational data in RSS feeds)'),
      'w3c' => t('W3C Geo (deprecated)'),
      'w3c_bugcompat' => t('Location 1.x-2.x compatible (buggy W3C)'),
      'simple' => t('GeoRSS-Simple'),
      'gml' => t('GeoRSS GML'),
    ),
    '#default_value' => isset($settings['rss']['mode']) ? $settings['rss']['mode'] : 'simple',
  );

  // @@@ THIS IS NOT GOOD. --Bdragon
  // clear the views cache in case anything was changed
  if (function_exists('views_invalidate_cache')) {
    views_invalidate_cache();
  }
}

/**
 * Custom submit function to save location settings properly.
 */
function _location_node_type_save_submit($form, &$form_state) {
  variable_set('location_settings_node_'. $form_state['values']['type'], $form_state['values']['location_settings']);

  // @@@ Backwards compatibility variables.
  // There are a few places in contrib where these variables are checked.
  variable_set('location_maxnum_'. $form_state['values']['type'], $form_state['values']['location_settings']['multiple']['max']);
  variable_set('location_defaultnum_'. $form_state['values']['type'], $form_state['values']['location_settings']['multiple']['add']);

  // Prevent the "normal" submit handler from stomping our variable.
  unset($form_state['values']['location_settings']);
}

/**
 * Alter the user_admin_settings form.
 */
function location_form_user_admin_settings_alter(&$form, &$form_state) {
  if (isset($form_state['values']['location_settings_user'])) {
    $settings = $form_state['values']['location_settings_user'];
  }
  else {
    $settings = variable_get('location_settings_user', array());
  }

  $form['location_settings_user'] = location_settings($settings);
  $form['location_settings_user']['#title'] = t('User locations');

  $form['location_settings_user']['form']['register'] = array(
    '#type' => 'checkbox',
    '#title' => t('Collect during registration'),
    '#default_value' => isset($settings['form']['register']) ? $settings['form']['register'] : FALSE,
    '#weight' => -5,
  );
}

/**
 * Implementation of hook_form_alter().
 */
function location_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['type']['#value']) && $form['type']['#value'] .'_node_form' == $form_id) {
    // Add the Location fields on the Node edit form
    $node = $form['#node'];
    $settings = variable_get('location_settings_node_'. $node->type, array());
    if (isset($settings['multiple']['max']) && $settings['multiple']['max'] > 0) {
      $form['locations'] = location_form($settings, $node->locations);
    }
  }
}

/**
 * Validation function for node settings form.
 * Logically, the default number of locations per node cannot
 * be bigger than the max locations.
 *
 * @ingroup $form
 */
function location_node_settings_validate($form, &$form_state) {
 // @@@ Fix validation again.
/*
  if (!empty($form_state['values']['location_maxnum']) && empty($form_state['values']['location_defaultnum'])) {
    form_set_error('location_defaultnum',
      t("You must have at least 1 default location-form enabled if you are going to allow locations to be submitted for nodes of this type. If you don't intend to allow locations to be submitted for nodes of this type, set the maximum number of locations allowed for this type to 0."));
  }
  elseif ($form_state['values']['location_defaultnum'] > $form_state['values']['location_maxnum']) {
    form_set_error('location_defaultnum',
      t("Your default number of location-forms that show up can't be greater than the maximum number of locations allowed for this node type."));
  }
*/
}

/**
 * Implementation of hook_nodeapi().
 */
function location_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'delete revision':
      $locations = array();
      location_save_locations($locations, array('vid' => $node->vid));
      break;
    case 'delete':
      $locations = array();
      location_save_locations($locations, array('nid' => $node->nid));
      break;
    case 'load':
      $locations = location_load_locations($node->vid);
      $location = count($locations) ? $locations[0] : array();
      return array('locations' => $locations, 'location' => $location);

    case 'insert':
    case 'update':
      if (!empty($node->locations)) {
        location_save_locations($node->locations, array('nid' => $node->nid, 'vid' => $node->vid));
      }
      break;

    case 'view':
      if (variable_get('location_display_location', 1)) {
        $settings = variable_get('location_settings_node_'. $node->type, array());
        if (isset($settings['display']['teaser']) && isset($settings['display']['full'])) {
          if (($a3 && $settings['display']['teaser']) || (!$a3 && $settings['display']['full'])) {
            $node->content['locations'] = location_display($settings, $node->locations);
          }
        }
      }
      break;

    case 'rss item':
      $items = array();
      $settings = variable_get('location_settings_node_'. $node->type, array());
      $mode = isset($settings['rss']['mode']) ? $settings['rss']['mode'] : 'simple';
      if ($mode == 'none') {
        return;
      }
      if (is_array($node->locations)) {
        foreach ($node->locations as $location) {
          if (!is_null($location['latitude']) && !is_null($location['longitude'])) {
            switch ($mode) {
              // W3C Basic Geo Vocabulary
              case 'w3c':
                $items[] = array(
                  'key'       => 'geo:Point',
                  'namespace' => array('xmlns:geo' => 'http://www.w3.org/2003/01/geo/wgs84_pos#'),
                  'value'     => array(
                    array('key' => 'geo:lat', 'value' => $location['latitude']),
                    array('key' => 'geo:long', 'value' => $location['longitude']),
                  ),
                );
                break;
              // Location 1.x-2.x bug compatible.
              // W3C Basic Geo Vocabulary with a misspelled longitude tag.
              case 'w3c_bugcompat':
                $items[] = array(
                  'key'       => 'geo:Point',
                  'namespace' => array('xmlns:geo' => 'http://www.w3.org/2003/01/geo/wgs84_pos#'),
                  'value'     => array(
                    array('key' => 'geo:lat', 'value' => $location['latitude']),
                    array('key' => 'geo:lon', 'value' => $location['longitude']),
                  ),
                );
                break;
              // GeoRSS-Simple
              case 'simple':
                $items[] = array(
                  'key'       => 'georss:point',
                  'namespace' => array('xmlns:georss' => 'http://www.georss.org/georss'),
                  'value'     => "$location[latitude] $location[longitude]",
                );
                break;
              //
              case 'gml':
                $items[] = array(
                  'key' => 'georss:where',
                  'namespace' => array(
                    'xmlns:georss' => 'http://www.georss.org/georss',
                    'xmlns:gml' => 'http://www.opengis.net/gml',
                  ),
                  'value' => array(
                    'gml:Point' => array(
                      'gml:pos' => "$location[latitude] $location[longitude]",
                    ),
                  ),
                );
                break;
            }
          }
        }
      }
      return $items;
  }
}

/**
 * Load associated locations.
 *
 * @param $id The identifier to match. (An integer.)
 * @param $key The search key for {location_instance} (usually vid or uid.)
 * @return An array of loaded locations.
 */
function location_load_locations($id, $key = 'vid') {
  $result = db_query('SELECT lid FROM {location_instance} WHERE '. db_escape_table($key) .' = %d', $id);
  $locations = array();
  while ($lid = db_fetch_object($result)) {
    $locations[] = location_load_location($lid->lid);
  }
  return $locations;
}

/**
 * Save associated locations.
 *
 * @param $locations The associated locations.
 *   You can pass an empty array to remove all location references associated
 *   with the given criteria. This is useful if you are about to delete an object,
 *   and need Location to clean up any locations that are no longer referenced.
 *
 * @param $criteria An array of instance criteria to save as.
 *   Example: array('genid' => 'my_custom_1111')
 */
function location_save_locations(&$locations, $criteria) {
  if (isset($locations) && is_array($locations) && !empty($criteria) && is_array($criteria)) {
    foreach (array_keys($locations) as $key) {
      location_save($locations[$key]);
    }
    $columns = array();
    $placeholders = array();
    $qfrags = array();
    $args = array();
    foreach (array('nid' => '%d', 'vid' => '%d', 'uid' => '%d', 'genid' => "'%s'") as $key => $placeholder) {
      if (isset($criteria[$key])) {
        $columns[] = $key;
        $placeholders[] = $placeholder;
        $args[] = $criteria[$key];
        $qfrags[] = "$key = $placeholder";
      }
    }
    $querybase = 'FROM {location_instance} WHERE '. implode(' AND ', $qfrags);

    $oldlids = array();
    $newlids = array();
    // Find affected lids.
    $query = "SELECT lid $querybase";
    $result = db_query($query, $args);
    while ($t = db_fetch_object($result)) {
      $oldlids[] = $t->lid;
    }

    $query = "DELETE $querybase";
    db_query($query, $args);
    // Tack on the lid.
    $columns[] = 'lid';
    $placeholders[] = '%d';

    foreach ($locations as $location) {
      // Don't save "empty" locations.
      // location_save() explicitly returns FALSE for empty locations,
      // so it should be ok to rely on the data type.
      if ($location['lid'] !== FALSE) {
        $args[] = $location['lid'];
        $newlids[] = $location['lid'];
        db_query('INSERT INTO {location_instance} ('. implode(', ', $columns) .') VALUES ('. implode(', ', $placeholders) .')', $args);
        array_pop($args);
      }
    }

    // Check anything that dropped a reference during this operation.
    foreach (array_diff($oldlids, $newlids) as $check) {
      // An instance may have been deleted. Check reference count.
      $count = db_result(db_query('SELECT COUNT(*) FROM {location_instance} WHERE lid = %d', $check));
      if ($count !== FALSE && $count == 0) {
        watchdog('location', t('Deleting unreferenced location with LID %lid.', array('%lid' => $check)));
        $location = array('lid' => $check);
        location_invoke_locationapi($location, 'delete');
        db_query('DELETE FROM {location} WHERE lid = %d', $location['lid']);
      }
    }
  }
}

/**
 * Load a single location by lid.
 *
 * @param $lid Location ID to load.
 * @return A location array.
 */
function location_load_location($lid) {
  $location = db_fetch_array(db_query('SELECT * FROM {location} WHERE lid = %d', $lid));
  // @@@ Just thought of this, but I am not certain it is a good idea...
  if (empty($location)) {
    $location = array('lid' => $lid);
  }
  if (isset($location['source']) && $location['source'] == LOCATION_LATLON_USER_SUBMITTED) {
    // Set up location chooser or lat/lon fields from the stored location.
    $location['locpick'] = array(
      'user_latitude' => $location['latitude'],
      'user_longitude' => $location['longitude'],
    );
  }
  $location['province_name'] = '';
  $location['country_name'] = '';

  if (!empty($location['country'])) {
    $location['country_name'] = location_country_name($location['country']);

    if (!empty($location['province'])) {
      $location['province_name'] = location_province_name($location['country'], $location['province']);
    }
  }

  $location = array_merge($location, location_invoke_locationapi($location, 'load', $lid));

  return $location;
}

/**
 * Implementation of hook_user().
 */
function location_user($op, &$edit, &$account, $category = NULL) {
  global $user;

  switch ($op) {
    case 'load':
      $account->locations = location_load_locations($account->uid, 'uid');
      $account->location = count($account->locations) ? $account->locations[0] : array();
      break;

    case 'insert':
    case 'update':
      if (!empty($edit['locations'])) {
        location_save_locations($edit['locations'], array('uid' => $account->uid));
      }
      unset($edit['locations']);
      break;

    case 'delete':
      $locations = array();
      location_save_locations($locations, array('uid' => $account->uid));
      break;

    case 'form':
      if ($category == 'account') {
        if ((($user->uid == $account->uid) && user_access('set own user location')) || user_access('administer user locations')) {
          $settings = variable_get('location_settings_user', array());
          $form['locations'] = location_form($settings, $account->locations);
          return $form;
        }
      }
      break;

    case 'register':
      $settings = variable_get('location_settings_user', array());
      if (isset($settings['form']['register']) && $settings['form']['register']) {
        $form['locations'] = location_form($settings, array());
        return $form;
      }
      break;

    case 'view':
      if ((($user->uid == $account->uid) && user_access('view own user location')) || user_access('administer users') || user_access('view all user locations') || user_access('administer user locations')) {
        if (variable_get('location_display_location', 1) && isset($account->locations) && count($account->locations)) {
          $settings = variable_get('location_settings_user', array());
          $account->content['locations'] = location_display($settings, $account->locations);
        }
      }
      break;
  }
}

/**
 * Create a list of states from a given country.
 *
 * @param $country
 *   String. The country code
 * @param $string
 *   String (optional). The state name typed by user
 * @return
 *   Javascript array. List of states
 */
function _location_autocomplete($country, $string = '') {
  $counter = 0;
  $string   = strtolower($string);
  $string   = '/^'. $string .'/';
  $matches  = array();
  $provinces = location_get_provinces($country);

  if (!empty($provinces)) {
    while (list($code, $name) = each($provinces)) {
      if ($counter < 5) {
        if (preg_match($string, strtolower($name))) {
          $matches[$name] = $name;
          ++$counter;
        }
      }
    }
  }
  echo drupal_to_js($matches);
  return;
}

/**
 * Epsilon test.
 * Helper function for seeing if two floats are equal.  We could use other functions, but all
 * of them belong to libraries that do not come standard with PHP out of the box.
 */
function _location_floats_are_equal($x, $y) {
  $x = floatval($x);
  $y = floatval($y);
  return (abs(max($x, $y) - min($x, $y)) < pow(10, -6));
}

/**
 * Check whether a location has coordinates or not.
 *
 * @param $location The location to check.
 * @param $canonical Is this a location that is fully saved?
 *   If set to TRUE, only the source will be checked.
 */
function location_has_coordinates($location, $canonical = FALSE) {
  // Locations that have been fully saved have an up to date source.
  if ($canonical) {
    return ($location['source'] != LOCATION_LATLON_UNDEFINED);
  }

  // Otherwise, we need to do the full checks.

  // If latitude or longitude are empty / missing
  if (empty($location['latitude']) || empty($location['longitude'])) {
    return FALSE;
  }

  // If the latitude or longitude are zeroed (Although it could be a good idea to relax this slightly sometimes)
  if (_location_floats_are_equal($location['latitude'], 0.0) || _location_floats_are_equal($location['longitude'], 0.0)) {
    return FALSE;
  }

  return TRUE;
}


/**
 * Invoke a hook_locationapi() operation on all modules.
 *
 * @param &$location A location object.
 * @param $op A string containing the name of the locationapi operation.
 * @param $a3, $a4, $a5 Arguments to pass on to the hook.
 * @return The returned value of the invoked hooks.
 */
function location_invoke_locationapi(&$location, $op, $a3 = NULL, $a4 = NULL, $a5 = NULL) {
  $return = array();
  foreach (module_implements('locationapi') as $name) {
    $function = $name .'_locationapi';
    $result = $function($location, $op, $a3, $a4, $a5);
    if (isset($result) && is_array($result)) {
      $return = array_merge($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Save a location.
 *
 * This is the central function for saving a location.
 * @param $location Location array to save.
 * @param $cow Copy-on-write, i.e. whether or not to assign a new lid if something changes.
 * @return The lid of the saved location, or FALSE if the location is considered "empty."
 */
function location_save(&$location, $cow = TRUE) {
  $inhibit_geocode = FALSE;

  $dummy = array();
  $virtual = location_invoke_locationapi($dummy, 'virtual fields');

  if (isset($location['delete_location']) && $location['delete_location']) {
    // Location is being deleted.
    // Stomp on it with the default values.
    $dummy = array();
    $location = location_invoke_locationapi($dummy, 'default values');
  }
  unset($location['delete_location']);

  // Remove the "virtual fields" from the location.
  foreach ($virtual as $field => $name) {
    unset($location[$field]);
  }

  $oldloc = array();
  if ($location['lid']) {
    $oldloc = (array)location_load_location($location['lid']);
    // Remove the "virtual fields" from the old location too.
    foreach ($virtual as $field => $name) {
      unset($oldloc[$field]);
    }
  }

  // @@@ This isn't the best place to do this...
  // But if the user only changes user lat/lon, we need to be able to detect it!
  if (!empty($location['locpick'])) {
    $location['locpick']['user_latitude'] = trim($location['locpick']['user_latitude']);
    $location['locpick']['user_longitude'] = trim($location['locpick']['user_longitude']);
  }
  // If the user location was set, convert it into lat / lon.
  if (!empty($location['locpick']['user_latitude']) && !empty($location['locpick']['user_longitude'])) {
    $location['source'] = LOCATION_LATLON_USER_SUBMITTED;
    $location['latitude'] = $location['locpick']['user_latitude'];
    $location['longitude'] = $location['locpick']['user_longitude'];
    $inhibit_geocode = TRUE;
  }

  // Pull in fields that hold data currently not editable directly by the user.
  $location = array_merge($oldloc, $location);

  $dummy = array();
  $emptyloc = location_invoke_locationapi($dummy, 'default values');

  // Effective location for determining "emptiness"
  $shadow = $location;
  unset($shadow['lid']);

  // Determine what fields were filled in.
  $filled = array();
  foreach ($shadow as $k => $v) {
    if ($k == 'locpick') {
      // The locpick element is "special".
      continue;
    }
    if (!isset($emptyloc[$k])) {
      // @@@ This is an error condition, a module is declaring a field without
      // a corresponding "empty" default!
      watchdog('Location', 'Module declared field without empty default!', array(), WATCHDOG_ERROR);
      continue;
    }
    if ($emptyloc[$k] == $v) {
      // Exact match, no change.
      continue;
    }
    else {
      // It wasn't equal, but perhaps it was equivilent?
      $results = location_invoke_locationapi($shadow, 'isunchanged', $k, $emptyloc[$k]);
      $changed = TRUE; // First, assume changed.
      foreach ($results as $r) {
        if ($r) {
          $changed = FALSE;
        }
      }
      if ($changed) {
        // Nobody answered affirmative, it must be different.
        $filled[$k] = TRUE;
      }
    }
  }

  if (empty($filled)) {
    // This location was empty.
    return FALSE;
  }

  // Change detection.
  $changed = array();
  foreach ($location as $k => $v) {
    if ($k == 'locpick') {
      // The locpick element is "special".
      continue;
    }
    if (!isset($oldloc[$k])) {
      // Field missing from old location, automatic save.
      $changed[$k] = TRUE;
      continue;
    }
    else if ($oldloc[$k] == $v) {
      // Exact match, no change.
      continue;
    }

    // It wasn't equal, but perhaps it was equivilent?
    $results = location_invoke_locationapi($location, 'isunchanged', $k, $oldloc[$k]);
    $waschanged = TRUE; // First, assume changed.
    foreach ($results as $r) {
      if ($r) {
        $waschanged = FALSE;
      }
    }
    if ($waschanged) {
      // Nobody okayed this difference.
      $changed[$k] = TRUE;
    }
  }

  if (empty($changed)) {
    // We didn't actually need to save anything.
    if (!empty($location['lid'])) {
      return $location['lid'];
    }
    else {
      // Unfilled location (@@@ Then how did we get here?)
      return FALSE;
    }
  }

  // Perform geocoding logic, coordinate normalization, etc.
  _location_geo_logic($location, $changed, $filled, $inhibit_geocode);

  // If we are in COW mode, we *probabaly* need to make a new lid.
  if ($cow) {
    // However, if it appears one or less times (i.e. is not shared), it's safe to recycle the lid.
    // Therefore, skip unsetting the prior lid if there are one or less rows in {location_instance} matching the lid.
    // See #306171 for more information.
    if (isset($location['lid']) && db_result(db_query('SELECT COUNT(*) FROM {location_instance} WHERE lid = %d', $location['lid'])) > 1) {
      unset($location['lid']);
    }
  }

  if (!empty($location['lid'])) {
    db_query('DELETE FROM {location} WHERE lid = %d', $location['lid']);
  }
  else {
    unset($location['lid']);
  }
  drupal_write_record('location', $location);

  location_invoke_locationapi($location, 'save');
  return $location['lid'];
}

/**
 * Perform geocoding logic, etc., prior to storing in the database.
 */
function _location_geo_logic(&$location, $changed, $filled, $inhibit_geocode = FALSE) {

  if (!$inhibit_geocode) {
    // Have any of the fields possibly affecting geocoding changed?
    // Or, was the location previously user submitted but is no longer?
    if ($changed['street'] || $changed['additional'] || $changed['city'] || $changed['province'] || $changed['country'] || $changed['postal_code'] || $location['source'] == LOCATION_LATLON_USER_SUBMITTED) {

      // Attempt exact geocoding.
      if ($data = location_latlon_exact($location)) {
        $location['source'] = LOCATION_LATLON_GEOCODED_EXACT;
        // @@@ How about an accuracy field here?
        $location['latitude'] = $data['lat'];
        $location['longitude'] = $data['lon'];
        // @@@ How about address normalization?
      }
      // Attempt inexact geocoding against a local postcode database
      elseif ($data = location_get_postalcode_data($location)) {
        $location['source'] = LOCATION_LATLON_GEOCODED_APPROX;
        $location['latitude'] = $data['lat'];
        $location['longitude'] = $data['lon'];
      }
      else {
        $location['source'] = LOCATION_LATLON_UNDEFINED;
        $location['latitude'] = 0;
        $location['longitude'] = 0;
      }
    }
  }

  // Normalize coordinates.
  while ($location['latitude'] > 90) {
    $location['latitude'] -= 180;
  }
  while ($location['latitude'] < -90) {
    $location['latitude'] += 180;
  }
  while ($location['longitude'] > 180) {
    $location['longitude'] -= 360;
  }
  while ($location['longitude'] < -180) {
    $location['longitude'] += 360;
  }

  // If city and/or province weren't set, see if we can fill them in with
  // postal data.
  if (!empty($location['postal_code'])) {
    if (empty($location['city']) || empty($location['province'])) {
      if ($data = location_get_postalcode_data($location)) {
        $location['city'] = $data['city'];
        $location['province'] = $data['province'];
      }
    }
  }

  // Normalize province.
  // Note: Validation is performed elsewhere. We assume that the province
  // specified matches either the short or long form of a province.
  if (!empty($location['province']) && !empty($location['country'])) {
    $location['province'] = location_province_code($location['country'], $location['province']);
  }

  // @@@ Now would be a GREAT time to hook.

}

/**
 * Perform validation against a location fieldset.
 */
function location_element_validate($form, &$form_state) {
  location_invoke_locationapi($form['#value'], 'validate', $form);
}

/**
 * Convert decimal degrees to degrees,minutes,seconds.
 */
function location_dd_to_dms($coord) {
  $negative = ($coord < 0) ? TRUE : FALSE;
  $coord = abs($coord);
  $degrees = floor($coord);
  $coord -= $degrees;
  $coord *= 60;
  $minutes = floor($coord);
  $coord -= $minutes;
  $coord *= 60;
  $seconds = round($coord, 6);
  return array($degrees, $minutes, $seconds, $negative);
}

/**
 * Display a coordinate.
 */
function theme_location_latitude_dms($latitude) {
  $output = '';
  list($degrees, $minutes, $seconds, $negative) = location_dd_to_dms($latitude);
  $output .= "${degrees}° ${minutes}' ${seconds}\" ";
  if (!$negative) {
    $output .= 'N';
  }
  else {
    $output .= 'S';
  }
  return $output;
}

function theme_location_longitude_dms($longitude) {
  $output = '';
  list($degrees, $minutes, $seconds, $negative) = location_dd_to_dms($longitude);
  $output .= "${degrees}° ${minutes}' ${seconds}\" ";
  if (!$negative) {
    $output .= 'E';
  }
  else {
    $output .= 'W';
  }
  return $output;
}

/**
 * Implementation of hook_token_values().
 */
function location_token_values($type, $object = NULL) {
  require_once(drupal_get_path('module', 'location') .'/location.token.inc');
  return _location_token_values($type, $object);
}

/**
 * Implementation of hook_token_list().
 */
function location_token_list($type = 'all') {
  require_once(drupal_get_path('module', 'location') .'/location.token.inc');
  return _location_token_list($type);
}

/**
 * Implementation of hook_search().
 * Implemented on behalf of location_search.module to make the urls not suck.
 */
function location_search($op = 'search', $keys = null) {
  if (module_exists('location_search')) {
    return _location_search($op, $keys);
  }
  // When search.module asks for name, return FALSE to tell it that we're disabled.
  if ($op == 'name') {
    return FALSE;
  }
}
/**
 * Theme preprocess function for a location.
 */
function template_preprocess_location(&$variables) {
  $location = $variables['location'];
  foreach($variables['hide'] as $key) {
    unset($location[$key]);
  }

  $fields = location_field_names(TRUE);
  foreach ($fields as $key => $value) {
    $variables[$key] = '';
    if (!empty($location[$key])) {
      $variables[$key] = check_plain($location[$key]);
    }
  }

  // Location name.
  $variables['name'] = '';
  if (!empty($location['name'])) {
    $variables['name'] = theme('placeholder', $location['name']);
  }

  // Map link.
  $variables['map_link'] = '';
  if (isset($variables['hide']['map_link']) && !$variables['hide']['map_link']) {
    $variables['map_link'] = location_map_link($location);
  }

  // Theme latitude and longitude as d/m/s.
  $variables['latitude'] = '';
  $variables['latitude_dms'] = '';
  if (!empty($location['latitude'])) {
    $variables['latitude'] = check_plain($location['latitude']);
    $variables['latitude_dms'] = theme('location_latitude_dms', $location['latitude']);
  }

  $variables['longitude'] = '';
  $variables['longitude_dms'] = '';
  if (!empty($location['longitude'])) {
    $variables['longitude'] = check_plain($location['longitude']);
    $variables['longitude_dms'] = theme('location_longitude_dms', $location['longitude']);
  }

  // Add a country-specific template suggestion.
  if (!empty($location['country']) && location_standardize_country_code($location['country'])) {
    // $location['country'] is normalized in the previous line.
    $variables['template_files'][] = 'location-'. $location['country'];
  }
}

/**
 * Theme preprocess function for location_distance.
 */
function template_preprocess_location_distance(&$variables) {
  $units = $variables['units'];
  unset($variables['units']);
  if ($units == 'km') {
    $variables['shortunit'] = 'km';
    $variables['longunit'] = 'kilometer(s)';
  }
  if ($units == 'mi') {
    $variables['shortunit'] = 'mi';
    $variables['longunit'] = 'mile(s)';
  }
  $variables['distance'] = (float)$variables['distance'];
}

/**
 * Theme preprocess function for theming a group of locations.
 */
function template_preprocess_locations(&$variables) {
  if (isset($variables['locations']) && is_array($variables['locations'])) {
    $locs = $variables['locations'];
  }
  else {
    // The locations weren't valid -- Use an empty array instead to avoid warnings.
    $locs = array();
  }
  $variables['locations'] = array();
  $variables['rawlocs'] = $locs;

  foreach ($locs as $location) {
    $variables['locations'][] = theme('location', $location, $variables['hide']);
  }
}

/**
 * Get a form element for configuring location for an object.
 */
function location_settings($old = FALSE) {
  if (empty($old)) {
    $old = array();
  }

  $form = array(
    '#type' => 'fieldset',
    '#title' => t('Locative information'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
  );

  $form['multiple'] = array(
    '#type' => 'fieldset',
    '#title' => t('Number of locations'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#weight' => 2,
  );
  $form['multiple']['min'] = array(
    '#type' => 'select',
    '#title' => t('Minimum number of locations'),
    '#options' => drupal_map_assoc(range(0, 100)),
    '#default_value' => isset($old['multiple']['min']) ? $old['multiple']['min'] : 0,
    '#description' => t('The number of locations that are required to be filled in.'),
  );
  $form['multiple']['max'] = array(
    '#type' => 'select',
    '#title' => t('Maximum number of locations'),
    '#options' => drupal_map_assoc(range(0, 100)),
    '#default_value' => isset($old['multiple']['max']) ? $old['multiple']['max'] : 0,
    '#description' => t('The maximum number of locations that can be associated.'),
  );
  // @@@ Dynamic location adding via ahah?
  $form['multiple']['add'] = array(
    '#type' => 'select',
    '#title' => t('Number of locations that can be added at once'),
    '#options' => drupal_map_assoc(range(0, 100)),
    '#default_value' => isset($old['multiple']['add']) ? $old['multiple']['add'] : 3,
    '#description' => t('The number of empty location forms to show when editing.'),
  );
  // Thought: What about prefilled names and fixed locations that way?
  // Then again, CCK would be cleaner.

  $form['form'] = array(
    '#type' => 'fieldset',
    '#title' => t('Collection settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#weight' => 4,
  );

  $form['form']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Location form weight'),
    '#default_value' => isset($old['form']['weight']) ? $old['form']['weight'] : 0,
    '#description' => t('Weight of the location box in the add / edit form. Lower values will be displayed higher in the form.'),
  );
  $form['form']['collapsible'] = array(
    '#type' => 'checkbox',
    '#title' => t('Collapsible'),
    '#default_value' => isset($old['form']['collapsible']) ? $old['form']['collapsible'] : TRUE,
    '#description' => t('Make the location box collapsible.'),
  );

  $form['form']['collapsed'] = array(
    '#type' => 'checkbox',
    '#title' => t('Collapsed'),
    '#default_value' => isset($old['form']['collapsed']) ? $old['form']['collapsed'] : TRUE,
    '#description' => t('Display the location box collapsed.'),
  );

  $form['form']['fields'] = array(
    '#type' => 'location_settings',
    '#default_value' => isset($old['form']['fields']) ? $old['form']['fields'] : array(),
  );

  $form['display'] = array(
    '#type' => 'fieldset',
    '#title' => t('Display Settings'),
//    '#description' => t('Here, you can change how locative data appears in nodes when viewed.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#weight' => 6,
  );

  $form['display']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Display Weight'),
    '#default_value' => isset($old['display']['weight']) ? $old['display']['weight'] : 0,
  );

  $fields = location_field_names(TRUE);
  $form['display']['hide'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Hide fields from display'),
    '#collapsed' => TRUE,
    '#default_value' => isset($old['display']['hide']) ? $old['display']['hide'] : array(),
    '#options' => $fields,
  );

  return $form;
}

/**
 * Get form elements for editing locations on an object.
 */
function location_form($settings, $locations) {
  if (!isset($settings['multiple']['max']) || $settings['multiple']['max'] == 0) {
    // Location not enabled for this object type.
    // Bail out early.
    return array();
  }

  // Generate location fieldsets.
  $numloc = count($locations);

  // Show up to 'add' number of additional forms, in addition to the preexisting
  // locations. (Less if we'll hit 'max' first.)
  $numforms = min($numloc + $settings['multiple']['add'], $settings['multiple']['max']);

  $form = array(
    '#type' => 'fieldset',
    '#title' => format_plural($numforms, 'Location', 'Locations'),
    '#tree' => TRUE,
    '#attributes' => array('class' => 'locations'),
    '#weight' => $settings['form']['weight'],
    '#collapsible' => $settings['form']['collapsible'],
    '#collapsed' => $settings['form']['collapsed'],
  );

  // If there is only one form, hide the outer fieldset.
  if ($settings['multiple']['max'] == 1) {
    $form['#type'] = 'markup';
  }

  // For non-required locations, we relax the settings.
  $fields = $settings['form']['fields'];

  // For required locations, we use strict settings.
  $fields_req = $settings['form']['fields'];

  // Relax non-required settings.
  foreach ($fields as $k => $v) {
    // Allow Allow (Use), Force Default settings through.
    // Block 2 (Required).
    $fields[$k] = $v & 1;
  }

  for ($i = 0; $i < $numforms; $i++) {
    $tmp = $fields;
    // If this one is required, use the strict settings...
    if ($i < $settings['multiple']['min']) {
      $tmp = $fields_req;
    }
    $form[$i] = array(
      '#type' => 'location_element',
      '#title' => t('Location #%number', array('%number' => $i + 1)),
      '#default_value' => isset($locations[$i]) ? $locations[$i] : NULL,
      // Use relaxed settings for all locations past the first one.
      '#location_settings' => $tmp,
    );
  }

  // Tidy up the form in the single location case.
  if ($numforms == 1) {
    $form[0]['#title'] = t('Location');
    // If the user had configured the form for a single location, inherit
    // the collapsible / collapsed settings.
    $form[0]['#collapsible'] = $form['#collapsible'];
    $form[0]['#collapsed'] = $form['#collapsed'];
  }

  return $form;
}

function location_display($settings, $locations) {
  if (!isset($settings['display']['hide'])) {
    // We weren't configured properly, bail.
    return array();
  }
  $hide = array_keys(array_filter($settings['display']['hide']));
  // Show all locations
  return array(
    '#type' => 'markup',
    '#value' => theme('locations', $locations, $hide),
    '#weight' => $settings['display']['weight'],
  );
}
